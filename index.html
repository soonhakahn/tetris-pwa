<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#0b1020" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <title>Tetris Neon</title>
  <link rel="manifest" href="./manifest.webmanifest" />
  <style>
    :root { color-scheme: dark; }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      color: #eef4ff;
      min-height: 100dvh;
      background:
        radial-gradient(circle at 20% 10%, #243b77 0%, transparent 35%),
        radial-gradient(circle at 80% 0%, #4b1d6e 0%, transparent 33%),
        linear-gradient(160deg, #080b17 0%, #0f1326 55%, #111a30 100%);
      display: grid;
      place-items: start center;
      padding: max(12px, env(safe-area-inset-top)) 12px max(16px, env(safe-area-inset-bottom));
    }
    .wrap { width: min(980px, 100%); display:grid; grid-template-columns:auto 300px; gap:14px; align-items:start; }
    .gameBox,.panel{
      background: rgba(11, 18, 35, .55);
      border: 1px solid rgba(141, 160, 255, .25);
      border-radius: 18px;
      backdrop-filter: blur(8px);
      box-shadow: 0 12px 30px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.06);
    }
    .gameBox { padding:10px; }
    canvas#game {
      display:block; width:min(90vw,480px); max-height:68dvh; height:auto;
      border-radius:12px; border:1px solid rgba(141, 160, 255, .22);
      background:#06080b; image-rendering:pixelated; touch-action:none;
    }
    .panel{ padding:14px; }
    .title{ font-weight:800; margin-bottom:10px; }
    .row{ display:flex; justify-content:space-between; margin:7px 0; }
    .row b{ color:#8de1ff; }
    .miniWrap{ display:grid; grid-template-columns:1fr 1fr; gap:10px; margin:10px 0 12px; }
    .mini{ border:1px solid rgba(141,160,255,.25); border-radius:12px; padding:8px; background:rgba(255,255,255,.03); }
    .mini label{ display:block; font-size:12px; opacity:.85; margin-bottom:6px; }
    .mini canvas{ width:100%; max-height:68dvh; height:auto; image-rendering:pixelated; background:#080b13; border-radius:8px; }
    .hint{ font-size:12px; opacity:.9; line-height:1.45; }
    .hr{ height:1px; background:rgba(141,160,255,.18); margin:10px 0; }
    button{
      width:100%; padding:11px 12px; margin-top:10px; border-radius:12px;
      border:1px solid rgba(141,160,255,.35);
      background:linear-gradient(180deg,#1f2a48,#121a33);
      color:#eef4ff; font-weight:700; cursor:pointer;
    }
    .touch{ display:none; margin-top:8px; gap:8px; }
    .touch button{ margin:0; min-height:48px; font-size:16px; }
    .sub{ opacity:.75; font-size:11px; margin-top:8px; }
    @media (max-width:860px){ .wrap{grid-template-columns:1fr;} .touch{display:flex;} }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="gameBox"><canvas id="game" width="320" height="640" aria-label="Tetris canvas"></canvas></div>
    <div class="panel">
      <div class="title">Tetris Neon</div>
      <div class="row"><span>ì ìˆ˜</span><b id="score">0</b></div>
      <div class="row"><span>ë ˆë²¨</span><b id="level">1</b></div>
      <div class="row"><span>ë¼ì¸</span><b id="lines">0</b></div>
      <div class="row"><span>ìµœê³ ì </span><b id="best">0</b></div>

      <div class="miniWrap">
        <div class="mini"><label>HOLD</label><canvas id="holdCv" width="96" height="96"></canvas></div>
        <div class="mini"><label>NEXT</label><canvas id="nextCv" width="96" height="96"></canvas></div>
      </div>

      <div class="hr"></div>
      <div class="hint">â†/â†’ ì´ë™ Â· â†‘(X) íšŒì „ Â· Z ë°˜íšŒì „ Â· â†“ ì†Œí”„íŠ¸ë“œë Â· Space í•˜ë“œë“œë Â· C í™€ë“œ Â· P ì¼ì‹œì •ì§€ Â· R ì¬ì‹œì‘</div>
      <div class="touch"><button id="tLeft">â†</button><button id="tRot">âŸ²</button><button id="tRight">â†’</button></div>
      <div class="touch"><button id="tDown">â†“</button><button id="tDrop">DROP</button><button id="tHold">HOLD</button></div>
      <button id="btn">Start</button>
      <button id="soundBtn">ğŸ”Š ì‚¬ìš´ë“œ ON</button>
      <div class="sub">iPhone: ìŠ¤ì™€ì´í”„ ì¢Œ/ìš°/ì•„ë˜, íƒ­ íšŒì „, ë”ë¸”íƒ­ í•˜ë“œë“œë</div>
    </div>
  </div>

<script>
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => navigator.serviceWorker.register('./sw.js').catch(() => {}));
}

class SFX {
  constructor(){ this.ctx=null; this.enabled=true; this.lastStep=0; }
  init(){
    if(!this.enabled) return;
    if(!this.ctx) this.ctx = new (window.AudioContext||window.webkitAudioContext)();
    if(this.ctx.state==='suspended') this.ctx.resume();
  }
  toggle(){ this.enabled=!this.enabled; if(this.enabled) this.init(); }
  tone(type,f0,f1,vol=0.08,dur=0.08){
    if(!this.enabled) return; this.init(); if(!this.ctx) return;
    const t=this.ctx.currentTime;
    const o=this.ctx.createOscillator();
    const g=this.ctx.createGain();
    o.type=type; o.frequency.setValueAtTime(f0,t);
    if(f1) o.frequency.exponentialRampToValueAtTime(Math.max(20,f1), t+dur);
    g.gain.setValueAtTime(vol,t); g.gain.exponentialRampToValueAtTime(0.0001,t+dur);
    o.connect(g); g.connect(this.ctx.destination); o.start(t); o.stop(t+dur+0.02);
  }
  noise(vol=0.06,dur=0.05){
    if(!this.enabled) return; this.init(); if(!this.ctx) return;
    const sr=this.ctx.sampleRate, len=Math.floor(sr*dur), b=this.ctx.createBuffer(1,len,sr), d=b.getChannelData(0);
    for(let i=0;i<len;i++) d[i]=(Math.random()*2-1)*(1-i/len);
    const src=this.ctx.createBufferSource(); const f=this.ctx.createBiquadFilter(); const g=this.ctx.createGain();
    f.type='highpass'; f.frequency.value=700; g.gain.value=vol; g.gain.exponentialRampToValueAtTime(0.0001,this.ctx.currentTime+dur);
    src.buffer=b; src.connect(f); f.connect(g); g.connect(this.ctx.destination); src.start(); src.stop(this.ctx.currentTime+dur+0.01);
  }
  start(){ this.tone('triangle',520,260,0.11,0.12); }
  move(){ this.tone('sine',300,260,0.03,0.04); }
  rotate(){ this.tone('square',520,780,0.06,0.06); }
  softDrop(){
    const now=performance.now(); if(now-this.lastStep<60) return; this.lastStep=now;
    this.tone('sine',170,120,0.03,0.03);
  }
  hardDrop(){ this.tone('sawtooth',240,70,0.08,0.09); this.noise(0.03,0.04); }
  lock(){ this.tone('triangle',140,100,0.07,0.06); }
  lineClear(n){
    const seq = n===4 ? [440,660,880,1320] : n===3 ? [392,523,659] : n===2 ? [349,440] : [330];
    seq.forEach((f,i)=>setTimeout(()=>this.tone('triangle',f,f*1.1,0.08,0.08), i*55));
  }
  levelUp(){ [523,659,784].forEach((f,i)=>setTimeout(()=>this.tone('triangle',f,f*1.2,0.09,0.1),i*80)); }
  gameOver(){ [330,247,196,147].forEach((f,i)=>setTimeout(()=>this.tone('sine',f,Math.max(60,f*0.7),0.08,0.14),i*110)); }
}

(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const holdCv = document.getElementById('holdCv');
  const nextCv = document.getElementById('nextCv');
  const hctx = holdCv.getContext('2d');
  const nctx = nextCv.getContext('2d');
  const scoreEl = document.getElementById('score');
  const levelEl = document.getElementById('level');
  const linesEl = document.getElementById('lines');
  const bestEl = document.getElementById('best');
  const btn = document.getElementById('btn');
  const soundBtn = document.getElementById('soundBtn');
  const sfx = new SFX();

  const COLS = 10, ROWS = 20, BLOCK = 32;
  const W = COLS * BLOCK, H = ROWS * BLOCK;
  canvas.width = W; canvas.height = H;

  const COLORS = { I:'#22c55e', O:'#eab308', T:'#a855f7', S:'#06b6d4', Z:'#ef4444', J:'#3b82f6', L:'#f97316', G:'#718096' };
  const SHAPES = {
    I:[[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]], O:[[1,1],[1,1]],
    T:[[0,1,0],[1,1,1],[0,0,0]], S:[[0,1,1],[1,1,0],[0,0,0]],
    Z:[[1,1,0],[0,1,1],[0,0,0]], J:[[1,0,0],[1,1,1],[0,0,0]], L:[[0,0,1],[1,1,1],[0,0,0]],
  };
  const PIECES = Object.keys(SHAPES);

  const clone = m => m.map(r => r.slice());
  const rotate = (m, dir) => {
    const N = m.length, r = Array.from({length:N},()=>Array(N).fill(0));
    for(let y=0;y<N;y++) for(let x=0;x<N;x++) dir>0 ? (r[x][N-1-y]=m[y][x]) : (r[N-1-x][y]=m[y][x]);
    return r;
  };
  const makeBoard = () => Array.from({length:ROWS},()=>Array(COLS).fill(''));
  const bag7 = () => { const a=PIECES.slice(); for(let i=a.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [a[i],a[j]]=[a[j],a[i]]; } return a; };

  let board = makeBoard(), queue = [], current = null, hold = null, holdUsed = false;
  let score=0, lines=0, level=1, best=Number(localStorage.getItem('tetris.best')||0);
  let running=false, paused=false, last=0, acc=0;

  function interval(){ return Math.max(70, 760 - (level-1)*55); }
  function refill(){ while(queue.length<7) queue.push(...bag7()); }
  function pieceFrom(type){
    let m=clone(SHAPES[type]);
    if(type!=='I' && type!=='O'){ const r=Array.from({length:3},()=>Array(3).fill(0)); for(let y=0;y<m.length;y++) for(let x=0;x<m[0].length;x++) r[y][x]=m[y][x]; m=r; }
    return { type, matrix:m, x:Math.floor((COLS-m[0].length)/2), y:-1 };
  }
  function spawn(){ refill(); current=pieceFrom(queue.shift()); holdUsed=false; if(collides(current)) gameOver(); }
  function gameOver(){ sfx.gameOver(); running=false; paused=false; btn.textContent='Start'; }
  function collides(p){
    for(let y=0;y<p.matrix.length;y++) for(let x=0;x<p.matrix[y].length;x++) if(p.matrix[y][x]){
      const bx=p.x+x, by=p.y+y;
      if (bx<0||bx>=COLS||by>=ROWS) return true;
      if (by>=0 && board[by][bx]) return true;
    }
    return false;
  }
  function merge(){
    const {matrix,x:px,y:py,type}=current;
    for(let y=0;y<matrix.length;y++) for(let x=0;x<matrix[y].length;x++) if(matrix[y][x]){ const by=py+y; if(by>=0) board[by][px+x]=type; }
  }
  function clearLines(){
    let c=0;
    outer: for(let y=ROWS-1;y>=0;y--){ for(let x=0;x<COLS;x++) if(!board[y][x]) continue outer; board.splice(y,1); board.unshift(Array(COLS).fill('')); c++; y++; }
    if(c){
      const prevLv=level;
      score += [0,100,300,500,800][c] * level;
      lines += c;
      level = 1 + (lines/10|0);
      sfx.lineClear(c);
      if(level>prevLv) sfx.levelUp();
    }
  }
  function lock(){ merge(); sfx.lock(); clearLines(); spawn(); }
  function move(dx){ const t={...current,x:current.x+dx}; if(!collides(t)){ current.x+=dx; sfx.move(); } }
  function softDrop(){ const t={...current,y:current.y+1}; if(!collides(t)){ current.y++; score++; sfx.softDrop(); } else lock(); }
  function hardDrop(){ let d=0, t={...current}; while(true){ t.y++; if(collides(t)){ t.y--; break; } d++; } current.y=t.y; score += d*2; sfx.hardDrop(); lock(); }
  function rotatePiece(dir){ if(current.type==='O') return; const r=rotate(current.matrix,dir); for(const k of [0,-1,1,-2,2]){ const t={...current,matrix:r,x:current.x+k}; if(!collides(t)){ current.matrix=r; current.x+=k; sfx.rotate(); return; } } }
  function holdSwap(){ if(!current||holdUsed) return; holdUsed=true; const cur=current.type; if(!hold){ hold=cur; spawn(); } else { const sw=hold; hold=cur; current=pieceFrom(sw); if(collides(current)) gameOver(); } }
  function ghostY(){ const t={...current}; while(true){ t.y++; if(collides(t)){ t.y--; return t.y; } } }
  function reset(){ board=makeBoard(); queue=[]; current=null; hold=null; holdUsed=false; score=0; lines=0; level=1; last=0; acc=0; spawn(); draw(); hud(); }

  function drawCell(x,y,color,a=1){ const px=x*BLOCK, py=y*BLOCK; ctx.globalAlpha=a; ctx.fillStyle=color; ctx.fillRect(px+1,py+1,BLOCK-2,BLOCK-2); ctx.globalAlpha=1; }
  function drawGrid(){ ctx.strokeStyle='rgba(255,255,255,.05)'; for(let x=1;x<COLS;x++){ ctx.beginPath(); ctx.moveTo(x*BLOCK,0); ctx.lineTo(x*BLOCK,H); ctx.stroke(); } for(let y=1;y<ROWS;y++){ ctx.beginPath(); ctx.moveTo(0,y*BLOCK); ctx.lineTo(W,y*BLOCK); ctx.stroke(); } }
  function drawMini(c,mctx,type){
    mctx.clearRect(0,0,c.width,c.height);
    mctx.fillStyle='#090d18'; mctx.fillRect(0,0,c.width,c.height);
    if(!type) return;
    const m=SHAPES[type], size=Math.floor(c.width/6), ox=Math.floor((c.width-m[0].length*size)/2), oy=Math.floor((c.height-m.length*size)/2);
    for(let y=0;y<m.length;y++) for(let x=0;x<m[y].length;x++) if(m[y][x]){ mctx.fillStyle=COLORS[type]; mctx.fillRect(ox+x*size, oy+y*size, size-2, size-2); }
  }
  function draw(){
    ctx.clearRect(0,0,W,H); ctx.fillStyle='#06080b'; ctx.fillRect(0,0,W,H);
    for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++) if(board[y][x]) drawCell(x,y,COLORS[board[y][x]]);
    if(current){ const gy=ghostY(); for(let y=0;y<current.matrix.length;y++) for(let x=0;x<current.matrix[y].length;x++) if(current.matrix[y][x]){ const by=gy+y; if(by>=0) drawCell(current.x+x,by,COLORS.G,.22); } }
    if(current){ for(let y=0;y<current.matrix.length;y++) for(let x=0;x<current.matrix[y].length;x++) if(current.matrix[y][x]){ const by=current.y+y; if(by>=0) drawCell(current.x+x,by,COLORS[current.type]); } }
    drawGrid();
    if(!running||paused){ ctx.fillStyle='rgba(0,0,0,.52)'; ctx.fillRect(0,0,W,H); ctx.fillStyle='#eef4ff'; ctx.textAlign='center'; ctx.font='700 30px system-ui'; ctx.fillText(!running?'TETRIS':'PAUSED',W/2,H/2-8); ctx.font='14px system-ui'; if(!running) ctx.fillText('Start ë˜ëŠ” R í‚¤',W/2,H/2+20); }
    drawMini(holdCv,hctx,hold); drawMini(nextCv,nctx,queue[0]);
  }
  function hud(){
    if(score>best){ best=score; localStorage.setItem('tetris.best', String(best)); }
    scoreEl.textContent=String(score); levelEl.textContent=String(level); linesEl.textContent=String(lines); bestEl.textContent=String(best);
    btn.textContent = running ? (paused?'Resume':'Pause') : 'Start';
    soundBtn.textContent = sfx.enabled ? 'ğŸ”Š ì‚¬ìš´ë“œ ON' : 'ğŸ”‡ ì‚¬ìš´ë“œ OFF';
  }
  function tick(t){
    if(!running){ draw(); hud(); return; }
    if(paused){ draw(); hud(); requestAnimationFrame(tick); return; }
    if(!last) last=t; acc += (t-last); last=t;
    while(acc>=interval()){
      acc-=interval();
      const nxt={...current,y:current.y+1};
      if(!collides(nxt)){ current.y++; sfx.softDrop(); }
      else lock();
    }
    draw(); hud(); requestAnimationFrame(tick);
  }
  function start(){ if(!current) reset(); running=true; paused=false; last=0; acc=0; sfx.start(); requestAnimationFrame(tick); }
  function togglePause(){ if(running) paused=!paused; }

  window.addEventListener('keydown', (e)=>{
    const k=e.key;
    if(k==='r'||k==='R'){ reset(); start(); return; }
    if(!running){ if(k==='Enter'||k===' ') { reset(); start(); } return; }
    if(k==='p'||k==='P'){ togglePause(); return; }
    if(paused) return;
    if(k==='ArrowLeft'){ e.preventDefault(); move(-1); }
    else if(k==='ArrowRight'){ e.preventDefault(); move(1); }
    else if(k==='ArrowDown'){ e.preventDefault(); softDrop(); }
    else if(k==='ArrowUp'||k==='x'||k==='X'){ e.preventDefault(); rotatePiece(+1); }
    else if(k==='z'||k==='Z'){ e.preventDefault(); rotatePiece(-1); }
    else if(k===' '){ e.preventDefault(); hardDrop(); }
    else if(k==='c'||k==='C'){ e.preventDefault(); holdSwap(); }
    draw(); hud();
  });

  btn.addEventListener('click', ()=>{ if(!running){ reset(); start(); } else togglePause(); draw(); hud(); });
  soundBtn.addEventListener('click', ()=>{ sfx.toggle(); hud(); });

  const bindTap=(id,fn)=>{ const el=document.getElementById(id); if(!el) return; const run=e=>{ e.preventDefault(); if(running&&!paused){ fn(); draw(); hud(); }}; el.addEventListener('touchstart',run,{passive:false}); el.addEventListener('mousedown',run); };
  function bindRepeat(id, fn, first=130, repeat=70){
    const el=document.getElementById(id); if(!el) return; let t1=null,t2=null;
    const clear=()=>{ if(t1) clearTimeout(t1); if(t2) clearInterval(t2); t1=t2=null; };
    const start=(e)=>{ e.preventDefault(); if(!running||paused) return; fn(); draw(); hud(); t1=setTimeout(()=>{ t2=setInterval(()=>{ if(running&&!paused){ fn(); draw(); hud(); } }, repeat); }, first); };
    ['touchstart','mousedown'].forEach(ev=>el.addEventListener(ev,start,{passive:false}));
    ['touchend','touchcancel','mouseup','mouseleave'].forEach(ev=>el.addEventListener(ev,clear));
  }
  bindRepeat('tLeft',()=>move(-1));
  bindRepeat('tRight',()=>move(1));
  bindRepeat('tDown',()=>softDrop(),120,60);
  bindTap('tRot',()=>rotatePiece(+1)); bindTap('tDrop',()=>hardDrop()); bindTap('tHold',()=>holdSwap());

  let sx=0, sy=0, st=0, lastTap=0;
  canvas.addEventListener('touchstart',(e)=>{ e.preventDefault(); const t=e.changedTouches[0]; sx=t.clientX; sy=t.clientY; st=Date.now(); }, {passive:false});
  canvas.addEventListener('touchend',(e)=>{
    e.preventDefault();
    if(!running){ reset(); start(); return; }
    if(paused){ paused=false; draw(); hud(); return; }
    const t=e.changedTouches[0], dx=t.clientX-sx, dy=t.clientY-sy, dt=Date.now()-st;
    const adx=Math.abs(dx), ady=Math.abs(dy);
    if(adx<14 && ady<14 && dt<220){ const now=Date.now(); if(now-lastTap<280) hardDrop(); else rotatePiece(+1); lastTap=now; }
    else if(adx>ady){ dx>0 ? move(1) : move(-1); }
    else { if(dy>24) softDrop(); else rotatePiece(+1); }
    draw(); hud();
  }, {passive:false});

  document.addEventListener('visibilitychange', ()=>{ if(document.hidden && running && !paused){ paused=true; draw(); hud(); } });
  window.addEventListener('blur', ()=>{ if(running && !paused){ paused=true; draw(); hud(); } });

  reset(); draw(); hud();
})();
</script>
</body>
</html>
