<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#0b1020" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <title>Tetris Neon</title>
  <link rel="manifest" href="./manifest.webmanifest" />
  <style>
    :root { color-scheme: dark; }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      color: #eef4ff;
      min-height: 100dvh;
      background:
        radial-gradient(circle at 20% 10%, #243b77 0%, transparent 35%),
        radial-gradient(circle at 80% 0%, #4b1d6e 0%, transparent 33%),
        linear-gradient(160deg, #080b17 0%, #0f1326 55%, #111a30 100%);
      display: grid;
      place-items: start center;
      padding: max(12px, env(safe-area-inset-top)) 12px max(16px, env(safe-area-inset-bottom));
    }
    .wrap {
      width: min(980px, 100%);
      display: grid;
      grid-template-columns: auto 300px;
      gap: 14px;
      align-items: start;
    }
    .gameBox, .panel {
      background: rgba(11, 18, 35, .55);
      border: 1px solid rgba(141, 160, 255, .25);
      border-radius: 18px;
      backdrop-filter: blur(8px);
      box-shadow: 0 12px 30px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.06);
    }
    .gameBox { padding: 10px; }
    canvas#game {
      display: block;
      width: min(90vw, 480px);
      height: auto;
      max-height: 68dvh;
      border-radius: 12px;
      border: 1px solid rgba(141, 160, 255, .22);
      background: #06080b;
      image-rendering: pixelated;
      touch-action: none;
    }
    .panel { padding: 14px; }
    .title { font-weight: 800; letter-spacing: .3px; margin-bottom: 10px; }
    .row { display:flex; justify-content:space-between; margin: 7px 0; }
    .row b { color: #8de1ff; }
    .miniWrap { display:grid; grid-template-columns: 1fr 1fr; gap:10px; margin: 10px 0 12px; }
    .mini {
      border: 1px solid rgba(141,160,255,.25);
      border-radius: 12px;
      padding: 8px;
      background: rgba(255,255,255,.03);
    }
    .mini label { display:block; font-size:12px; opacity:.85; margin-bottom:6px; }
    .mini canvas { width: 100%; height: auto;
      max-height: 68dvh; image-rendering: pixelated; background: #080b13; border-radius: 8px; }
    .hint { font-size: 12px; opacity: .9; line-height: 1.45; }
    .hr { height:1px; background: rgba(141,160,255,.18); margin:10px 0; }
    button {
      width:100%; padding:11px 12px; margin-top: 10px; border-radius: 12px;
      border: 1px solid rgba(141,160,255,.35);
      background: linear-gradient(180deg, #1f2a48, #121a33);
      color:#eef4ff; font-weight:700; cursor:pointer;
    }
    button:active { transform: translateY(1px); }
    .touch { display: none; margin-top: 8px; gap: 8px; }
    .touch button { margin: 0; min-height: 48px; font-size: 16px; }
    .sub { opacity:.75; font-size:11px; margin-top:8px; }
    @media (max-width: 860px) {
      .wrap { grid-template-columns: 1fr; }
      .touch { display: flex; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="gameBox">
      <canvas id="game" width="320" height="640" aria-label="Tetris canvas"></canvas>
    </div>

    <div class="panel">
      <div class="title">Tetris Neon</div>
      <div class="row"><span>점수</span><b id="score">0</b></div>
      <div class="row"><span>레벨</span><b id="level">1</b></div>
      <div class="row"><span>라인</span><b id="lines">0</b></div>
      <div class="row"><span>최고점</span><b id="best">0</b></div>

      <div class="miniWrap">
        <div class="mini"><label>HOLD</label><canvas id="holdCv" width="96" height="96"></canvas></div>
        <div class="mini"><label>NEXT</label><canvas id="nextCv" width="96" height="96"></canvas></div>
      </div>

      <div class="hr"></div>
      <div class="hint">
        조작: ←/→ 이동, ↑(X) 회전, Z 반회전, ↓ 소프트드랍, Space 하드드랍, C 홀드, P 일시정지, R 재시작
      </div>
      <div class="touch">
        <button id="tLeft">←</button><button id="tRot">⟲</button><button id="tRight">→</button>
      </div>
      <div class="touch">
        <button id="tDown">↓</button><button id="tDrop">DROP</button><button id="tHold">HOLD</button>
      </div>
      <button id="btn">Start</button>
      <div class="sub">iPhone: 캔버스 스와이프(좌/우/아래), 탭 회전, 더블탭 하드드랍</div>
    </div>
  </div>

<script>
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => navigator.serviceWorker.register('./sw.js').catch(() => {}));
}
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const holdCv = document.getElementById('holdCv');
  const nextCv = document.getElementById('nextCv');
  const hctx = holdCv.getContext('2d');
  const nctx = nextCv.getContext('2d');
  const scoreEl = document.getElementById('score');
  const levelEl = document.getElementById('level');
  const linesEl = document.getElementById('lines');
  const bestEl = document.getElementById('best');
  const btn = document.getElementById('btn');

  const COLS = 10, ROWS = 20, BLOCK = 32;
  const W = COLS * BLOCK, H = ROWS * BLOCK;
  canvas.width = W; canvas.height = H;

  const COLORS = { I:'#22c55e', O:'#eab308', T:'#a855f7', S:'#06b6d4', Z:'#ef4444', J:'#3b82f6', L:'#f97316', G:'#718096' };
  const SHAPES = {
    I:[[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]], O:[[1,1],[1,1]],
    T:[[0,1,0],[1,1,1],[0,0,0]], S:[[0,1,1],[1,1,0],[0,0,0]],
    Z:[[1,1,0],[0,1,1],[0,0,0]], J:[[1,0,0],[1,1,1],[0,0,0]], L:[[0,0,1],[1,1,1],[0,0,0]],
  };
  const PIECES = Object.keys(SHAPES);

  const clone = m => m.map(r => r.slice());
  const rotate = (m, dir) => {
    const N = m.length, r = Array.from({length:N},()=>Array(N).fill(0));
    for (let y=0;y<N;y++) for (let x=0;x<N;x++) dir>0 ? (r[x][N-1-y]=m[y][x]) : (r[N-1-x][y]=m[y][x]);
    return r;
  };
  const makeBoard = () => Array.from({length:ROWS},()=>Array(COLS).fill(''));
  const bag7 = () => { const a=PIECES.slice(); for(let i=a.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [a[i],a[j]]=[a[j],a[i]]; } return a; };

  let board = makeBoard(), queue = [], current = null, hold = null, holdUsed = false;
  let score=0, lines=0, level=1, best=Number(localStorage.getItem('tetris.best')||0);
  let running=false, paused=false, last=0, acc=0;

  function interval(){ return Math.max(70, 760 - (level-1)*55); }
  function refill(){ while(queue.length<7) queue.push(...bag7()); }
  function pieceFrom(type){
    let m=clone(SHAPES[type]);
    if (type!=='I' && type!=='O'){ const r=Array.from({length:3},()=>Array(3).fill(0)); for(let y=0;y<m.length;y++) for(let x=0;x<m[0].length;x++) r[y][x]=m[y][x]; m=r; }
    return { type, matrix:m, x:Math.floor((COLS-m[0].length)/2), y:-1 };
  }
  function spawn(){ refill(); current=pieceFrom(queue.shift()); holdUsed=false; if (collides(current)) gameOver(); }
  function gameOver(){ running=false; paused=false; btn.textContent='Start'; }
  function collides(p){
    for(let y=0;y<p.matrix.length;y++) for(let x=0;x<p.matrix[y].length;x++) if(p.matrix[y][x]){
      const bx=p.x+x, by=p.y+y;
      if (bx<0||bx>=COLS||by>=ROWS) return true;
      if (by>=0 && board[by][bx]) return true;
    }
    return false;
  }
  function merge(){
    const {matrix,x:px,y:py,type}=current;
    for(let y=0;y<matrix.length;y++) for(let x=0;x<matrix[y].length;x++) if(matrix[y][x]){ const by=py+y; if(by>=0) board[by][px+x]=type; }
  }
  function clearLines(){
    let c=0;
    outer: for(let y=ROWS-1;y>=0;y--){ for(let x=0;x<COLS;x++) if(!board[y][x]) continue outer; board.splice(y,1); board.unshift(Array(COLS).fill('')); c++; y++; }
    if(c){ score += [0,100,300,500,800][c] * level; lines += c; level = 1 + (lines/10|0); pulse(); }
  }
  function lock(){ merge(); clearLines(); spawn(); }
  function move(dx){ const t={...current,x:current.x+dx}; if(!collides(t)) current.x+=dx; }
  function softDrop(){ const t={...current,y:current.y+1}; if(!collides(t)){ current.y++; score++; } else lock(); }
  function hardDrop(){ let d=0, t={...current}; while(true){ t.y++; if(collides(t)){ t.y--; break; } d++; } current.y=t.y; score += d*2; lock(); }
  function rotatePiece(dir){ if(current.type==='O') return; const r=rotate(current.matrix,dir); for(const k of [0,-1,1,-2,2]){ const t={...current,matrix:r,x:current.x+k}; if(!collides(t)){ current.matrix=r; current.x+=k; return; }} }
  function holdSwap(){
    if(!current||holdUsed) return; holdUsed=true;
    const cur=current.type;
    if(!hold){ hold=cur; spawn(); }
    else { const sw=hold; hold=cur; current=pieceFrom(sw); if(collides(current)) gameOver(); }
  }
  function ghostY(){ const t={...current}; while(true){ t.y++; if(collides(t)){ t.y--; return t.y; } } }
  function reset(){ board=makeBoard(); queue=[]; current=null; hold=null; holdUsed=false; score=0; lines=0; level=1; last=0; acc=0; spawn(); draw(); hud(); }

  function drawCell(x,y,color,a=1){ const px=x*BLOCK, py=y*BLOCK; ctx.globalAlpha=a; ctx.fillStyle=color; ctx.fillRect(px+1,py+1,BLOCK-2,BLOCK-2); ctx.globalAlpha=1; }
  function drawGrid(){ ctx.strokeStyle='rgba(255,255,255,.05)'; for(let x=1;x<COLS;x++){ ctx.beginPath(); ctx.moveTo(x*BLOCK,0); ctx.lineTo(x*BLOCK,H); ctx.stroke(); } for(let y=1;y<ROWS;y++){ ctx.beginPath(); ctx.moveTo(0,y*BLOCK); ctx.lineTo(W,y*BLOCK); ctx.stroke(); } }
  function drawMini(c,mctx,type){
    mctx.clearRect(0,0,c.width,c.height);
    mctx.fillStyle='#090d18'; mctx.fillRect(0,0,c.width,c.height);
    if(!type) return;
    const m=SHAPES[type], size=Math.floor(c.width/6), ox=Math.floor((c.width-m[0].length*size)/2), oy=Math.floor((c.height-m.length*size)/2);
    for(let y=0;y<m.length;y++) for(let x=0;x<m[y].length;x++) if(m[y][x]){ mctx.fillStyle=COLORS[type]; mctx.fillRect(ox+x*size, oy+y*size, size-2, size-2); }
  }
  function pulse(){ if(navigator.vibrate) navigator.vibrate(18); }
  function draw(){
    ctx.clearRect(0,0,W,H); ctx.fillStyle='#06080b'; ctx.fillRect(0,0,W,H);
    for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++) if(board[y][x]) drawCell(x,y,COLORS[board[y][x]]);
    if(current){ const gy=ghostY(); for(let y=0;y<current.matrix.length;y++) for(let x=0;x<current.matrix[y].length;x++) if(current.matrix[y][x]){ const by=gy+y; if(by>=0) drawCell(current.x+x,by,COLORS.G,.22); } }
    if(current){ for(let y=0;y<current.matrix.length;y++) for(let x=0;x<current.matrix[y].length;x++) if(current.matrix[y][x]){ const by=current.y+y; if(by>=0) drawCell(current.x+x,by,COLORS[current.type]); } }
    drawGrid();
    if(!running||paused){ ctx.fillStyle='rgba(0,0,0,.52)'; ctx.fillRect(0,0,W,H); ctx.fillStyle='#eef4ff'; ctx.textAlign='center'; ctx.font='700 30px system-ui'; ctx.fillText(!running?'TETRIS':'PAUSED',W/2,H/2-8); ctx.font='14px system-ui'; if(!running) ctx.fillText('Start 또는 R 키',W/2,H/2+20); }
    drawMini(holdCv,hctx,hold); drawMini(nextCv,nctx,queue[0]);
  }
  function hud(){
    if(score>best){ best=score; localStorage.setItem('tetris.best', String(best)); }
    scoreEl.textContent=String(score); levelEl.textContent=String(level); linesEl.textContent=String(lines); bestEl.textContent=String(best);
    btn.textContent = running ? (paused?'Resume':'Pause') : 'Start';
  }

  function tick(t){
    if(!running){ draw(); hud(); return; }
    if(paused){ draw(); hud(); requestAnimationFrame(tick); return; }
    if(!last) last=t; acc += (t-last); last=t;
    while(acc>=interval()){ acc-=interval(); const nxt={...current,y:current.y+1}; if(!collides(nxt)) current.y++; else lock(); }
    draw(); hud(); requestAnimationFrame(tick);
  }
  function start(){ if(!current) reset(); running=true; paused=false; last=0; acc=0; requestAnimationFrame(tick); }
  function togglePause(){ if(running) paused=!paused; }

  window.addEventListener('keydown', (e)=>{
    const k=e.key;
    if(k==='r'||k==='R'){ reset(); start(); return; }
    if(!running){ if(k==='Enter'||k===' ') { reset(); start(); } return; }
    if(k==='p'||k==='P'){ togglePause(); return; }
    if(paused) return;
    if(k==='ArrowLeft'){ e.preventDefault(); move(-1); }
    else if(k==='ArrowRight'){ e.preventDefault(); move(1); }
    else if(k==='ArrowDown'){ e.preventDefault(); softDrop(); }
    else if(k==='ArrowUp'||k==='x'||k==='X'){ e.preventDefault(); rotatePiece(+1); }
    else if(k==='z'||k==='Z'){ e.preventDefault(); rotatePiece(-1); }
    else if(k===' '){ e.preventDefault(); hardDrop(); }
    else if(k==='c'||k==='C'){ e.preventDefault(); holdSwap(); }
    draw(); hud();
  });

  btn.addEventListener('click', ()=>{ if(!running){ reset(); start(); } else togglePause(); draw(); hud(); });
  const bindTap=(id,fn)=>{ const el=document.getElementById(id); if(!el) return; const run=e=>{ e.preventDefault(); if(running&&!paused){ fn(); draw(); hud(); }}; el.addEventListener('touchstart',run,{passive:false}); el.addEventListener('mousedown',run); };
  function bindRepeat(id, fn, first=130, repeat=70){
    const el=document.getElementById(id); if(!el) return; let t1=null,t2=null;
    const clear=()=>{ if(t1) clearTimeout(t1); if(t2) clearInterval(t2); t1=t2=null; };
    const start=(e)=>{ e.preventDefault(); if(!running||paused) return; fn(); draw(); hud(); t1=setTimeout(()=>{ t2=setInterval(()=>{ if(running&&!paused){ fn(); draw(); hud(); } }, repeat); }, first); };
    ['touchstart','mousedown'].forEach(ev=>el.addEventListener(ev,start,{passive:false}));
    ['touchend','touchcancel','mouseup','mouseleave'].forEach(ev=>el.addEventListener(ev,clear));
  }
  bindRepeat('tLeft',()=>move(-1));
  bindRepeat('tRight',()=>move(1));
  bindRepeat('tDown',()=>softDrop(),120,60);
  bindTap('tRot',()=>rotatePiece(+1)); bindTap('tDrop',()=>hardDrop()); bindTap('tHold',()=>holdSwap());

  // swipe/tap controls on canvas (mobile)
  let sx=0, sy=0, st=0, lastTap=0;
  canvas.addEventListener('touchstart',(e)=>{ e.preventDefault(); const t=e.changedTouches[0]; sx=t.clientX; sy=t.clientY; st=Date.now(); }, {passive:false});
  canvas.addEventListener('touchend',(e)=>{
    e.preventDefault();
    if(!running){ reset(); start(); return; }
    if(paused){ paused=false; draw(); hud(); return; }
    const t=e.changedTouches[0], dx=t.clientX-sx, dy=t.clientY-sy, dt=Date.now()-st;
    const adx=Math.abs(dx), ady=Math.abs(dy);
    if(adx<14 && ady<14 && dt<220){
      const now=Date.now();
      if(now-lastTap<280) hardDrop(); else rotatePiece(+1);
      lastTap=now;
    } else if(adx>ady){ dx>0 ? move(1) : move(-1); }
    else { if(dy>24) softDrop(); else rotatePiece(+1); }
    draw(); hud();
  }, {passive:false});


  document.addEventListener('visibilitychange', ()=>{ if(document.hidden && running && !paused){ paused=true; draw(); hud(); } });
  window.addEventListener('blur', ()=>{ if(running && !paused){ paused=true; draw(); hud(); } });

  reset(); draw(); hud();
})();
</script>
</body>
</html>
